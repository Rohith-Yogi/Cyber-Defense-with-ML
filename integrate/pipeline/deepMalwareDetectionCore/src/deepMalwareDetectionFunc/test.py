import argparse
import logging
import os
import pickle
import numpy as np
import lief
import pefile

from pipeline.deepMalwareDetectionCore.src.deepMalwareDetectionFunc.models import MalConvPlus, MalConvBase
import torch
from pipeline.deepMalwareDetectionCore.src.deepMalwareDetectionFunc.dataset import make_loader_predict
from pipeline.deepMalwareDetectionCore.src.deepMalwareDetectionFunc.utils import load_model_from_ckp
from torch import sigmoid

def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--device", type=str, default="cpu")
    parser.add_argument("--model", type=str, default="MalConvPlus")
    parser.add_argument("--model_path", type=str, default="assets/checkpoints/malconv_plus_50.pt")
    parser.add_argument("--input_path", type=str, default="data/dasmalwerk/")
    parser.add_argument("--embed_dim", type=int, default=8)
    parser.add_argument("--max_len", type=int, default=4096)
    parser.add_argument("--out_channels", type=int, default=128)
    parser.add_argument("--window_size", type=int, default=32)
    parser.add_argument("--dropout", type=float, default=0.5)
    args = parser.parse_args()
    return args


def main(args):
    # model_cls = getattr(models, args.model)
    device = torch.device(args.device)
    model = MalConvPlus(
        args.embed_dim, args.max_len, args.out_channels, args.window_size, args.dropout
    ).to(device)
    data = make_loader_predict(args.input_path,is_malware=True)
    ans = load_model_from_ckp(model,args.model_path,data,args.device)
    # print(ans)
    # ans = (torch.cat([ans]) > 0).to(int) -- to get probability 
    ans = sigmoid(torch.cat([ans]))
    print(ans)
    if(ans[0]>=0.5):
        print("Its MALWARE !!!")
    else:
        print("Its GOODWARE ???")

    return ans

class MalConvPlus_model:
    def __init__(self):
        model="MalConvPlus"
        device="cpu"
        embed_dim=8
        max_len=4096
        out_channels=128
        window_size=32
        dropout=0.5
        model_path="assets/malconv_plus_40.pt"
        
        self.device = torch.device(device)
        self.model = MalConvPlus(
            embed_dim, max_len, out_channels, window_size, dropout
        ).to(self.device)
        self.checkpoint = torch.load(model_path, map_location=torch.device('cpu'))


    def predict_threshold(self, bytez, threshold):
        
        with open('temp.dll', 'wb') as f:
            f.write(bytez)
        # pe_file = lief.PE.parse('AcGenral.dll')
        # print(pefile)
        pe_file = pefile.PE('temp.dll')
        header = list(pe_file.header)
        with open(os.path.join("data/", f"test.pickle"), "wb") as f:
            pickle.dump(header, f)
        data = make_loader_predict('data/',is_malware=True)
        ans = load_model_from_ckp(self.model,self.checkpoint,data,self.device)
        # print(ans)
        # ans = (torch.cat([ans]) > 0).to(int) -- to get probability 
        ans = sigmoid(torch.cat([ans]))
        ans = ans.cpu().detach().numpy()
        ans = ans[0]
        print(ans)
        if(ans>=0.5):
            print("Its MALWARE !!!")
        else:
            print("Its GOODWARE ???")
        return ans

class MalConvBase_model:
    def __init__(self):
        model="MalConvBase"
        device="cpu"
        embed_dim=8
        max_len=4096
        out_channels=128
        window_size=32
        dropout=0.5
        model_path="assets/malconv_base_30.pt"
        
        self.device = torch.device(device)
        self.model = MalConvBase(
            embed_dim, max_len, out_channels, window_size, dropout
        ).to(self.device)
        self.checkpoint = torch.load(model_path, map_location=torch.device('cpu'))


    def predict_threshold(self, bytez, threshold):
        
        # with open('temp.dll', 'wb') as f:
        #     f.write(bytez)
        # pe_file = lief.PE.parse('AcGenral.dll')
        # print(pefile)
        pe_file = pefile.PE('temp.dll')
        header = list(pe_file.header)
        with open(os.path.join("data/", f"test.pickle"), "wb") as f:
            pickle.dump(header, f)
        data = make_loader_predict('data/',is_malware=True)
        ans = load_model_from_ckp(self.model,self.checkpoint,data,self.device)
        # print(ans)
        # ans = (torch.cat([ans]) > 0).to(int) -- to get probability 
        ans = sigmoid(torch.cat([ans]))
        ans = ans.cpu().detach().numpy()
        ans = ans[0]
        print(ans)
        if(ans>=0.5):
            print("Its MALWARE !!!")
        else:
            print("Its GOODWARE ???")
        return ans



# if __name__ == "__main__":
#     args = get_args()
#     main(args)

